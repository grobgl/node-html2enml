// Generated by CoffeeScript 1.10.0
var DOMParser, Evernote, NOTEHEADER, PROHIBITEDATTR, PROHIBITEDTAGS, SparkMD5, XMLHttpRequest, XMLSerializer, async, base1, fs, htmlEnmlConverter, ref,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

async = require('async');

XMLHttpRequest = require('xhr2');

SparkMD5 = require('spark-md5');

ref = require('xmldom'), DOMParser = ref.DOMParser, XMLSerializer = ref.XMLSerializer;

Evernote = require('evernote').Evernote;

if ((base1 = String.prototype).startsWith == null) {
  base1.startsWith = function(s) {
    return this.slice(0, s.length) === s;
  };
}

NOTEHEADER = '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">';

PROHIBITEDTAGS = ["applet", "base", "basefont", "bgsound", "blink", "button", "dir", "embed", "fieldset", "form", "frame", "frameset", "head", "iframe", "ilayer", "input", "isindex", "label", "layer", "legend", "link", "marquee", "menu", "meta", "noframes", "noscript", "object", "optgroup", "option", "param", "plaintext", "script", "select", "style", "textarea", "xml"];

PROHIBITEDATTR = ["id", "class", "onclick", "ondblclick", "accesskey", "data", "dynsrc", "tabindex"];

htmlEnmlConverter = (function() {
  function htmlEnmlConverter() {
    this.requests = [];
    this.resources = [];
    this.parser = new DOMParser;
    this.serializer = new XMLSerializer;
  }

  htmlEnmlConverter.prototype.convert = function(htmlString, baseUrl, callback) {
    var doc;
    doc = this.parser.parseFromString(htmlString, 'text/html');
    return this._convertNodes(doc, baseUrl, (function(_this) {
      return function(err) {
        var enml, errors, testdoc;
        doc = doc.getElementsByTagName('body')[0];
        doc.tagName = 'en-note';
        enml = NOTEHEADER + _this.serializer.serializeToString(doc);
        testdoc = _this.parser.parseFromString(enml);
        errors = testdoc.getElementsByTagName('parsererror');
        if (errors.length) {
          return callback(new Error('Failed to parse'));
        } else {
          return callback(null, enml, _this.resources);
        }
      };
    })(this));
  };

  htmlEnmlConverter.prototype._toArrayBuffer = function(buffer) {
    var ab, i, j, len, unit, view;
    ab = new ArrayBuffer(buffer.length);
    view = new Uint8Array(ab);
    for (i = j = 0, len = buffer.length; j < len; i = ++j) {
      unit = buffer[i];
      view[i] = unit;
    }
    return ab;
  };

  htmlEnmlConverter.prototype._convertMedia = function(element, url, callback) {
    var fileExists, request;
    request = new XMLHttpRequest;
    request.element = element;
    request.open('GET', url, true);
    request.responseType = 'arraybuffer';
    request.onload = (function(_this) {
      return function(e) {
        var hash, i, j, len, mime, ref1, resource, response, spark, str;
        response = e.target;
        console.log(request);
        console.log(response);
        if (response.status === 200) {
          spark = new SparkMD5.ArrayBuffer;
          spark.append(response.response);
          hash = spark.end;
          mime = response.getResponseHeader('content-type');
          response.element.tagName = 'en-media';
          response.element.setAttribute('hash', hash);
          response.element.setAttribute('type', mime);
          str = _this.serializer.serializeToString(response.element);
          response.element.removeAttribute('src');
          resource = new Evernote.Resource({
            mime: mime
          });
          resource.data = new Evernote.Data;
          resource.data.body = response.response;
          resource.data.bodyHash = hash;
          _this.resources.push(resource);
        }
        ref1 = _this.requests;
        for (i = j = 0, len = ref1.length; j < len; i = ++j) {
          request = ref1[i];
          if (request === response) {
            _this.requests.splice(i, 1);
          }
        }
        if (_this.requests.length === 0) {
          return callback();
        }
      };
    })(this);
    if (url.indexOf('http' === -1)) {
      fileExists = fs.existsSync(url);
      return request.onload({
        target: {
          status: fileExists ? 200 : 404,
          response: fileExists ? this._toArrayBuffer(fs.readFileSync(url)) : null,
          element: element,
          getResponseHeader: function() {
            return 'image/png';
          }
        }
      });
    } else {
      this.requests.push(request);
      return request.send();
    }
  };

  htmlEnmlConverter.prototype._adjustUrl = function(relative, base) {
    var j, len, part, parts, stack;
    if (relative.startsWith('http:') || relative.startsWith('https:') || relative.startsWith('file:') || relative.startsWith('evernote:')) {
      return relative;
    }
    stack = base.split('/');
    parts = relative.split('/');
    stack.pop();
    for (j = 0, len = parts.length; j < len; j++) {
      part = parts[j];
      if (part === '.') {
        continue;
      }
      if (part === '..') {
        stack.pop();
      } else {
        stack.push(part);
      }
    }
    return stack.join('/');
  };

  htmlEnmlConverter.prototype._convertNodes = function(domNode, baseUrl, callback) {
    var tagName;
    tagName = domNode.tagName ? domNode.tagName.toLowerCase() : '';
    if (indexOf.call(PROHIBITEDTAGS, tagName) >= 0) {
      domNode.parentNode.removeChild(domNode);
      return callback();
    } else if (domNode.attributes || domNode.childNodes) {
      return async.parallel([
        (function(_this) {
          return function(callback) {
            if (!domNode.attributes) {
              return callback();
            }
            return async.each(domNode.attributes, function(attribute, callback) {
              var attributeName;
              attributeName = attribute.name.toLowerCase();
              if (indexOf.call(PROHIBITEDATTR, attributeName) >= 0) {
                domNode.attributes.removeNamedItem(attribute.name);
                return callback();
              } else if (attributeName === 'href' && tagName === 'a') {
                attribute.value = _this._adjustUrl(attribute.value, baseUrl);
                if (!attribute.value) {
                  domNode.attributes.removeNamedItem(attribute.name);
                }
                return callback();
              } else if (attributeName === 'src' && tagName === 'img') {
                attribute.value = _this._adjustUrl(attribute.value, baseUrl);
                if (!attribute.value) {
                  domNode.parentNode.removeChild(domNode);
                  return callback();
                } else {
                  return _this._convertMedia(domNode, attribute.value, callback);
                }
              } else {
                return callback();
              }
            }, callback);
          };
        })(this), (function(_this) {
          return function(callback) {
            if (!domNode.childNodes) {
              return callback();
            }
            return async.each(domNode.childNodes, function(childNode, callback) {
              return _this._convertNodes(childNode, baseUrl, callback);
            }, callback);
          };
        })(this)
      ], callback);
    } else {
      return callback();
    }
  };

  return htmlEnmlConverter;

})();

module.exports.fromString = function(htmlString, baseUrl, callback) {
  return new htmlEnmlConverter().convert(htmlString, baseUrl, callback);
};

module.exports.fromFile = function(file, baseUrl, callback) {
  return fs.readFile(file, 'utf8', function(err, htmlString) {
    if (err) {
      callback(err);
    }
    return new htmlEnmlConverter().convert(htmlString, baseUrl, callback);
  });
};
